																					Продвинутый CSharp
													
													
	1) Рефлексия - это механизм, который позволяет получать информацию о типах, их членах(методы, свойства, поля и события) и атрибутах во время выполнения программы. Она также позволяет динамически создавать экземпляр класса, вызывать методы и получать доступ к закрытым типам(protected, private)
	Основной функционал рефлексии сосредоточен в пространстве имен System.Reflection. 

	Основные классы:
		- Assembly - класс, предстовляющий сборку и позволяет ею манипулировать;
		- AssemblyName - класс, хранящий информацию о сборке;
		- MemberInfo - базовый абстрактный класс, определяющий функционал для классов EventInfo, FieldInfo, MethodInfo и PropertyInfo;
		- EventInfo - класс, хранящий информации о событиях;
		- FieldInfo - класс, хранящий информацию об определенном типе;
		- MethodInfo - класс, хранит информацию об определенном методе;
		- PropertyInfo - хранит информацию о параметре метода;
		- ConstructorInfo - класс, предоставляющий конструктор;
		- Module - класс, позволяющий получить доступ;
		- ParameteInfo - класс, хранящий информацию о параметре метода.

	Чтобы получить информацию о членах типа нужно воспользоваться классом System.Type.
	C помощью класса Type можно получить всю информацию о изучаемом типе:
		- Методы:
			- FindMembers() - возвращает массив объектов MemberInfo данного типы;
			- GetConstructors() - возвращает все конструкторы данного типа в виде набора объектов ConstructorInfo;
			- GetEvents() - возвращает все события данного типа в виде массива объектов EventInfo;
			- GetFields() - возвращает все поля данного типа в виде массива объектов FieldInfo;
			- GetInterfaces() - получает все реализуемые данным типом интерфейсы в виде массива объектов Type;
			- GetMembers() - возвращает все члены типа в виде массива объектов MemberInfo;
			- GetMethods() - получает все методы типа в виде массива объектов MethodInfo;
			- GetProperties() - получает все свойства в виде массива объектов PropertyInfo;
		- Свойства:
			- Name - возвращает имя типа;
			- FullName - возвращает полное имя типа;
			- Namespace - возвращает пространство имен типа;
			- Assembly - возвращает название сборки, где определен тип;
			- Namespace - возвращает название пространства имен, где определен тип;
			- IsArray - возвращает true, если тип является массивом;
			- IsClass - возвращает true, если тип представляет класс;
			- IsValueType - возвращает true, если тип является структурой;
			- IsEnum - возвращает true, если тип является перечислением;
			- IsInterface - возвращает true, если тип представляет интерфейс;
	
	Чтобы управлять типом и получать всю информацию о нем, нам надо сперва получить тип. 
	Это можно сделать 3 способами:
		- typeof(ClassName) - получение типа на этапе компиляции 
		Пример:
			Type myType = typeof(Person);
			Console.WriteLine(myType);  // Person

		- obj.GetType() - получение типа
		Пример:
			Person tom = new Person("Tom");
			Type myType = tom.GetType();
			
		- Type.GetType("Namespace.ClassName") - получение типа по строковому имени 
		Пример:				
			Type? myType = Type.GetType("Person", false, true);
		Разбор работы:
			- Первый параметр указывает на полное имя класса с пространством имен. 
			- Второй параметр указывает, будет ли генерироваться исключение, если класс не удастся найти. В данном случае значение false означает, что исключение не будет генерироваться.
			- Третий параметр указывает, надо ли учитывать регистр символов в первом параметре. Значение true означает, что регистр игнорируется. Поскольку указанный тип может отсутствовать, то метод 				возвращает объект nullable-типа.
			
	Если нужный нам тип находиться в другой сборке, то после полного именни после запятой указываем имя сборки:
		Пример:
			- Type myType = Type.GetType("PeopleTypes.Person, MyLibrary", false, true);
	
	
																				Получение всех компонентов типа
	

	Метод GetMembers() возвращает все доступные компоненты типа в виде объекта MemberInfo. Этот объект позволяет извлечь некоторую информацию о компоненте типа. В частности, некоторые его свойства:
	DeclaringType: возвращает полное название типа.
	MemberType: возвращает значение из перечисления MemberTypes:
		MemberTypes.Constructor
		MemberTypes.Method
		MemberTypes.Field
		MemberTypes.Event
		MemberTypes.Property
		MemberTypes.NestedType
	Name: возвращает название компонента	
		
	Пример:	
		Type myType = typeof(Person);
		foreach (MemberInfo member in myType.GetMembers())
		{
			Console.WriteLine($"{member.DeclaringType} {member.MemberType} {member.Name}");
		}		
			
			
																						BindingFlags
																				
	
	BindingFlags - перечисление, которое используется для управления поиском членов класса(методов, полей, свойств и т.д.) при работе с рефлексией. Позволяет указать какие именно члены нужно искать:
	 - DeclaredOnly - получает только методы непосредственно данного класса, унаследованные методы не извлекаются;
	 - Instance - получает только методы экземпляра;
	 - NonPublic - извлекает не публичные методы;
	 - Public - получает только публичные методы;
	 - Static - получает только статические методы.


------------------------ 
					Посмотреть "Получение информации о методах, Исследование параметров, Получение конструкторов, Получение информации о полях, Получение и изменение значения поля и Свойства"
------------------------


																						Делегаты

			
	Делегат (delegate) — это указатель на метод, который позволяет передавать методы как параметры другим методам.
	
	Используются:		
		- Делегаты позволяют передавать методы как параметры
		- Поддерживают мультиметоды (multicast) с +=  
		- Используются в обработке событий (event) и LINQ
		- Func, Action, Predicate — упрощают работу с делегатами
	
	Встроенные делегаты:		
		- Action<T> - Делегат без возвращаемого значения (void)
		- Func<T, TResult> - Делегат с возвращаемым значением
		- Predicate<T> - Делегат, который возвращает bool
		
		
																					Анонимные типы
																					
																					
	Анонимный тип — это тип данных, создаваемый компилятором, без явного объявления класса. Он используется для временного хранения данных, когда не нужно создавать отдельный класс или структуру.
	Особенности:
	    - Не имеют имени – тип генерируется компилятором автоматически.
		- Только для чтения (read-only) – свойства нельзя изменить после создания.
		- Локальная область видимости – используются внутри метода, нельзя вернуть из метода (без приведения к object или dynamic).
		- Сравниваются по значению – два анонимных объекта с одинаковыми свойствами и значениями будут равны.

			
																					Анонимные методы
		  
		  
	Анонимные методы - это способ создания встроенных блоков кода без явного объявления отдельного метода. Они были представлены в C# 2.0 как предшественники лямбда-выражений.
	
	Основные характеристики:
		- Не имеют имени - определяются непосредственно в месте использования
		- Создаются с помощью ключевого слова delegate
		- Могут быть преобразованы в делегаты
		- Могут захватывать переменные из окружающего контекста (closures)
		
		Пример:
			delegate void SimpleDelegate();
		    SimpleDelegate del = delegate() { Console.WriteLine("Это анонимный метод") };
		  
			
																					Ламбда-выражения
			
			
	Лямбда-выражения - это компактный способ написания анонимных функций, представленный в C# 3.0. Они представляют собой мощный инструмент для создания делегатов и деревьев выражений.
	
	Action:
		Делегат Название функции = (передача параметров) => действие; 
		Action greet = () = Console.WriteLine("Анонимная функция");
		
	Func:
		Делегат<T1, T2..., T result> название функции = (передача параметров) =>  действие;
		Func<int, int, int> sum = (x, y) => x+y;
		Console.WriteLine($"Сумма - {sum(5, 5)}")
			
	
																					Интерфейс IDisposable
			
			
	Интерфейс IDisposable используется для освобождения неуправляемых ресурсов. Он содержит единственный метод Dispose(), который нужно реализовывать для правильной очистки ресурсов.
	Используют:
		- Очистка неуправляемых ресурсов;
		- Очистка управляемых ресурсов, которые реализуют интерфейс IDisposable
		
	Освобождение неуправляемых ресурсов подразумевает реализацию одного из двух механизмов создание деструктора и реализация классом интерфейса System.IDisposable
			
	Деструктор - это специальный метод который автоматически вызывается сборщиком мусора (GC) перед удалением объекта из памяти. Метод деструктора носит имя класса, но перел которым стоит знак тильда(~)
	Особенности:
		- Класс может иметь только 1 деструктор;
		- Не может иметь модификаторов доступа и параметры;
		- Определить деструкторы можно только в классах.
	Пример:
		class Person
		{
			public string Name { get;}
			public Person(string name) => Name = name;
		 
			~Person()
			{
				Console.WriteLine($"{Name} has deleted");
			}
		}
		
	Деструктор вызывается когда GC определяет объект под удаление, однако при очистке GC вызывает не деструктор, а метод Finalize. Все потому что при компиляции деструктор преобразуется в структуру:
	0
	protected override void Finalize()
	{
		try
		{
		    // здесь идут инструкции деструктора
		}
		finally
		{
		    base.Finalize();
		}
	}
	
	Метод Finalize уже определен в базовом классе Object, однако его нельзя просто переопределить, и фактическая его реализация происходит через создание деструктора. После конца жизненного цикла Person в консоле появиться сообщение об удаление объекта Tom
	Пример:
		GC.Collect();   // очистка памяти под объект tom
		Console.Read(); // ставим задержку
		 
		void Test()
		{
			Person tom = new Person("Tom");
		}
		 
		public class Person
		{
			public string Name { get;}
			public Person(string name) => Name = name;
		 
			~Person()
			{
				Console.WriteLine($"{Name} has been deleted");
			}
		}
		
		
																						Конструкция using
			
			
	Синтаксис C# предлагает похожую конструкцию для автоматического вызова метода Dispose - конструкцию using:
	using (Person tom = new Person("Tom"))
	{
		//
	}
	Получается конструкция using оформляет блок кода и создает объект, который реализует интерфейс IDisposable, в частности метод Dispose. При завершение блока кода у объекта вызывается метод Dispose.
			
	!!! Важно, что данная конструкция реализуется для типов, которые реализуют интерфейс IDisposable !!!
	
	Пример:
		Person tom = new Person("Tom");
		try
		{
			// ...
		}
		finally
		{
			if (tom != null)
			{
				((IDisposable)tom).Dispose();
			}
		} 
			
			
																						Структура DateTime
																						
		
	Для работы с датами и временнем в .net предназначена структура DateTime. 
	От 00:00:00 01.01.0001 до 23:59:59 31.12.9999
	
	Чтобы реализовать новый объект DateTime можно использовать конструктор
	Пример:
		DateTime dateTime = new DateTime(год, месяц, день, час, минута, секунда );
		Console.WriteLine(dateTime); // 01.01.0001 0:00:00
	
	Свойства:
		- DateTime.Now берет текущую дату и время компьютера, 
		- DateTime.UtcNow - дата и время относительно времени по Гринвичу (GMT) 
		- DateTime.Today - только текущая дата.
		
	Методы:
		- Add(TimeSpan value) - добавляет к дате значение TimeSpan
		- AddDays(double value) - добавляет к текущей дате несколько дней
		- AddHours(double value) - добавляет к текущей дате несколько часов
		- AddMinutes(double value) - добавляет к текущей дате несколько минут
		- AddMonths(int value) - добавляет к текущей дате несколько месяцев
		- AddYears(int value) - добавляет к текущей дате несколько лет		
		
		- Subtract(DateTime date) - используется для вычитания даты 
		Пример:
			DateTime date1 = new DateTime(2015, 7, 20, 18, 30, 25); // 20.07.2015 18:30:25
			DateTime date2 = new DateTime(2015, 7, 20, 15, 30, 25); // 20.07.2015 15:30:25
			Console.WriteLine(date1.Subtract(date2)); // 03:00:00 разница
			
	Так же чтобы вычитать дату и время можно указывать отрицательные значения.
	
	Методы для форматирования:
		- DateTime date1 = new DateTime(2015, 7, 20, 18, 30, 25);
		- Console.WriteLine(date1.ToLocalTime()); // 20.07.2015 21:30:25
		- Console.WriteLine(date1.ToUniversalTime()); // 20.07.2015 15:30:25
		- Console.WriteLine(date1.ToLongDateString()); // 20 июля 2015 г.
		- Console.WriteLine(date1.ToShortDateString()); // 20.07.2015
		- Console.WriteLine(date1.ToLongTimeString()); // 18:30:25
		- Console.WriteLine(date1.ToShortTimeString()); // 18:30
	
	Так же мы можем сделать свой формат Дата/Время
	Пример:
	DateTime now = DateTime.Now; 
	Console.WriteLine(now.ToString("hh:mm:ss"));  // 12:46:38
	Console.WriteLine(now.ToString("dd.MM.yyyy"));
			
			
																						DateOnly и TimeOnly
																						
																					
	Для упрощения работы с датами и временнем в .NET были 6 были добавлены две дополнительные структуры DateOnly и TimeOnly.
	
	DateOnly - дата без времени
	TimeOnly - время без даты 
	
	Методы DateOnly:
		- AddDays(int days) - добавляет к дате некоторое количество дней
		- AddMonths(int months) - добавляет к дате некоторое количество месяцев
		- AddYears(int years) - добавляет к дате некоторое количество лет
		- ToDateTime(TimeOnly) - возвращает объект DateTime, который в качестве даты использует текущий объект DateOnly, а в качестве времени - значение параметра в виде TimeOnly
		- ToLongDateString() - выводит текущий объект DateOnly в виде подробной даты
		- ToShortDateString() - выводит текущий объект DateOnly в виде сжатой даты
			
	Методы TimeOnly:
		- AddHours(double hours) - добавляет к времени некоторое количество часов
		- AddMinutes(double minutes) - добавляет к времени некоторое количество минут
		- Add(TimeSpan value) - добавляет время из объекта TimeSpan
		- ToLongTimeString() - выводит текущий объект TimeOnly в виде подробного времени
		- ToShortTimeString() - выводит текущий объект TimeOnly в виде сжатого времени
			

																						Компараторы
			
			
	Интерфейсы IComparer и IComparable - используются для сортировки объектов в C# и других операциях, которые требуют сравнение объектов. 
	
	IComparable - это интерфейс, который реализуется объектами, если эти объекты должны поддерживать сравнение с другими объектами того же типа. Интерфейс определяет метод CompareTo(), который используется для сравнения текущего объекта с другим объектом того же типа.
	Метод CompareTo принимает один параметр — объект, с которым необходимо сравнить текущий. 
	Он должен возвращать:
		- 0, если объекты равны.
		- -1, если текущий объект меньше переданного.
		- 1, если текущий объект больше переданного.

	IComparer - это интерфейс, который используется для сравнения двух объектов произвольного типа.	
	Метод Compare принимает два объекта типа object и сравнивает их. 
	Он должен возвращать:
		- 0, если объекты равны.
		- -1, если первый объект меньше второго.
		- 1, если первый объект больше второго.

	IComparable используется для сортировки по умолчанию.
	IComparer используется, если нужно создать кастомное правило сортировки или сравнение объектов, например, сортировка по разным полям.


																						LINQ


	LINQ (Language-Integrated Query) представляет простой и удобный язык запросов к источнику данных. В качестве источника данных может выступать объект, реализующий интерфейс IEnumerable (например, стандартные коллекции, массивы), набор данных DataSet, документ XML. Но вне зависимости от типа источника LINQ позволяет применить ко всем один и тот же подход для выборки данных.

	Существует несколько разновидностей LINQ:
		- LINQ to Objects - применяется для работы с массивами и коллекциями
		- LINQ to Entities - используется при обращении к базам данных через технологию Entity Framework
		- LINQ to XML - применяется при работе с файлами XML
		- LINQ to DataSet - применяется при работе с объектом DataSet
		- Parallel LINQ (PLINQ) - используется для выполнения параллельных запросов

	LINQ использует функциональные делегаты как фундамент для своей работы:
		- Func<T, TResult> — для методов, которые что-то возвращают
		- Action<T> — для методов, которые ничего не возвращают
		- Predicate<T> — для методов, которые возвращают bool



	В LINQ все методы делятся на два вида:

	- промежуточные методы - это методы, которые не запускают выполнение запроса. Они просто настраивают цепочку операций, возвращая объект IEnumerable<T> (или IQueryable<T>), 
с которым можно продолжить работу. Они не выполняются сразу. Вместо этого они откладывают выполнение до тех пор, пока не будет вызван терминальный метод.

	- терминальные методы - это методы, которые запускают выполнение LINQ-запроса и возвращают не IEnumerable, 
а конкретный результат: коллекцию, значение или число. Когда вызывается терминальный метод — вся цепочка промежуточных методов исполняется.

------------------------ 
					Посмотреть "Посмотреть свойства промежуточные методы и терминальных методов"
					
					посмотреть тред пул
					кол-во максимальных потоков
					разрешение ризкондишен
					что такое монитор в многопоточности
------------------------











			

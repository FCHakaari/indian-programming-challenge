1) Рефлексия в C#: что это, как можно применять? Как получить поля и методы, используя рефлексию?
Ответ:
	Рефлексия — это механизм, позволяющий получать информацию о типах, их членах (полях, свойствах, методах) и манипулировать ими во время выполнения программы. То есть основная задача рефлексии - это исследование типов.
	Чтобы получить поля и методы используются 3 основных способа:
		- Type type1 = typeof(MyClass);        // через оператор typeof
		- Type type2 = myObject.GetType();     // через экземпляр объекта
		- Type type3 = Type.GetType("Namespace.MyClass"); // по имени типа
	
	BindingFlags - это перечесление в C# которое используется для управления процессом при работе с типами, их членами и создания экземпляра. Позволяет указать фильтры, что именно искать: какие члены искать(публичные/не публичные, статические\не статические), как выполнять поиск (игнорировать/ не игнория регистр), учитывать ли членов, унаследованных от базовых типов.
	Пример:
		Type myType = typeof(Person)
		
		foreach (MemberInfo member in myType.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public))
		{
			Console.WriteLine($"{member.DeclaredOnly }");
		}

2) Dependency Injection (DI): что это такое? Как можно использовать?
Ответ:
	Dependency Injection (DI) — это шаблон проектирования, который реализует принцип Inversion of Control (IoC), позволяющий внедрять зависимости в классы вместо того, чтобы классы сами создавали свои зависимости.
	Это паттерн проектирования, который позволяет сделать ваши классы более гибкими и тестируемыми
	Основные принципы DI:
	    - Разделение ответственности - класс не должен создавать свои зависимости
	    - Слабая связность - компоненты зависят от абстракций, а не от конкретных реализаций
	    - Тестируемость - легко подменять зависимости для тестирования
	    - Гибкость - можно менять реализацию зависимостей без изменения кода класса
	Как можно использоавть??????????????????????????????????????????????????????????
	
3) Inversion of Control (IoC): в чем заключается идея? Как это можно использовать?
Ответ: 
	Это некий абстрактный принцип, для написания слобосвязанного кода. Суть в том, что каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов 
	
4) Что такое анонимный тип? Что такое анонимный метод?
Ответ: 																			
	Анонимный тип — это тип данных, создаваемый компилятором, без явного объявления класса. Он используется для временного хранения данных, когда не нужно создавать отдельный класс или структуру.
	Особенности:
	    - Не имеют имени – тип генерируется компилятором автоматически.
		- Только для чтения (read-only) – свойства нельзя изменить после создания.
		- Локальная область видимости – используются внутри метода, нельзя вернуть из метода (без приведения к object или dynamic).
		- Сравниваются по значению – два анонимных объекта с одинаковыми свойствами и значениями будут равны.
	Пример:
		var person = new { Name = "Ivan", Age = 18}; // ReadOnly
		  
	Анонимные методы - это способ создания встроенных блоков кода без явного объявления отдельного метода. Они были представлены в C# 2.0 как предшественники лямбда-выражений.
	Основные характеристики:
		- Не имеют имени - определяются непосредственно в месте использования
		- Создаются с помощью ключевого слова delegate
		- Могут быть преобразованы в делегаты
		- Могут захватывать переменные из окружающего контекста (closures)
		
	Пример:
		delegate void SimpleDelegate();
    		SimpleDelegate del = delegate() { Console.WriteLine("Это анонимный метод") };
		  
5) Что такое делегаты? Как они работают и для чего они нужны?
Ответы:
	Делегаты - это указатели на метод, который позволяет передавать методы как параметры другим методам;
	
6) Для чего используются Lambda-методы? В чем их отличия от обычной реализации методов и функций?
Ответ: 
	Лямбда-функции - это упрощенная форма записи анонимных методов. Удобный способ быстро описать небольшую функцию прямо в коде, особенно когда она нужна только один раз. Они делают код чище и компактнее, но не заменяют обычные методы в сложных сценариях.
	Пример:
		Тип(Делегат/неявный тип) = (параметры) => выражение
		Тип(Делегат/неявный тип) = (параметры) 
		{
			выражение 1
			выражение 2
		}
	Плюсы лямбда-выражений:
		- Краткость — меньше кода, особенно для простых операций.
		- Удобство — не нужно объявлять отдельный метод.
		- Замыкания — могут использовать переменные из внешней области видимости.
		- Широкое применение — LINQ, асинхронность, события, делегаты.

	Минусы:
		- Сложная отладка — анонимные функции сложнее анализировать в отладчике.
		- Не для сложной логики — если код большой, лучше вынести в отдельный метод.
	
7) Жизненный цикл объектов в C#
Ответ:
	В C# жизненный цикл объекта управляется сборщиком мусора (Garbage Collector, GC). Он автоматически освобождает память, когда объекты больше не используются.
	Жизненный цикл объекта разделяется на несколько пунктов:
		- Создание;
		- Использование;
		- Удаление ссылок;
		- Очистка GC;
		- Финализация, если объект использует неуправляемые ресурсы, то нужно очистить используя IDisposable

8) Что такое деструкторы класса? Зачем они нужны? Как их реализовать?
Ответы:
	Деструктор (финализатор) — это специальный метод класса, который автоматически вызывается сборщиком мусора (GC) перед удалением объекта из памяти. Он необходим для освобождения неуправляемых ресурсов и логирования.
	Этапы работы finalize:
		- Создание объекта в куче, если объект содержит в себе деструктор, то GC помечает его в специальной таблице Finalization Queue.
		- Конец жизненого цикла( удаление ссылок ). Все объекты находящиеся в таблице Finalization Queue с концом жизненного цикла переходят в следующию таблицу Freachable Queue.
		- Вызов деструктора ( Finalize ) и после окончательно помечается на удаление
		- Удаление. При следующем проходе GC объект удаляется, только если была создана новая ссылка на объект, то GC не удалит его и он снова станет "Досягаемым" 
	Пример:
		class Percon
		{
			~Percon(), то есть деструктор должен иметь тоже имя, что и реализуемый класс
			{
			
			}
		}
	
9)Интерфейс IDisposable: как использовать? Для чего используется? Как реализуется?	
Ответы:
	Интерфейс IDisposable используется для освобождения неуправляемых ресурсов. Для освобождения таких ресурсов необходимо, чтобы объект реализовывал IDisposable для того, чтобы предоставить механизмы для их явного освобождения
	IDisposable объявляет всего один метод Dispose, в котором при реализации интерфейса в классе должно происходить освобождение неуправляемых ресурсов. 
	
10) Сколько значений возвращает метод в C#? Как можно вернуть несколько значений?
Ответ:
	Метод может возвращать одно значения. 
	Чтобы вернуть несколько значений можно использовать разные подходы:
		- Вернуть кортежи;
		- Использовать параметр Out. Параметр Out - выходной параметр.
		- Вернуть массив или коллекцию;
		- Создать структруку и вернуть структуру;
	
11) Что такое перегрузка (overloading)? Как перегрузка используется в классах?
Ответ:
	Перегрузка (overloading) — это возможность определять несколько методов, операторов или конструкторов с одинаковым именем, но разными параметрами (по количеству, типу или порядку). Компилятор сам выбирает нужную версию метода на основе переданных аргументов.
	В классах перегрузка используется для:
		- Методов - создания нескольких версий метода с разными параметрами;
		- Конструкторов - предоставление разных способов инициализации объекта;
		- Оператор, к примеру "+, -, *, /"

12) Что такое DRY, KISS, YAGNI? Примеры использования  принципов
Ответ:
	Это принципы написания чистого кода, где:
		- DRY - Don`t Repeat Yourself("Не повторяйся")
			Суть в том, чтобы избегать повторяющийся код, выносить его в отдельные методы
		- KISS - Keep It Simple? Stupid("Делай проще")
			Суть в том, чтобы делать код максимально простым и понятным, без лишней сложности
		- YAGNI - You Aren`t Gonna Need It ("Вам это не понадобится") 
			Суть в том, чтобы не добавлять функционал на будущее, если он не нужен прямо сейчас 
	
13) Работа с датами:
	- Как получить текущую дату?  
	- Как получить UNIX TIMESTAMP текущего времени?  
	- Как осуществлять форматирование даты и времени?	
Ответ:
	Для работы с датами и временнем используется структура DateTime. Начинается с 00:00:00 01:01:0001 и до 23:59:59 31.12.9999
	Для более комфортной работы были добавлены 2 доп.струтуры: DateOnly и TimeOnly
	UNIX TIMESTAMP - это кол-во секунд прошедших с 01.01.1970. Это дата начала эпохи Unix по всемирному координированному времени (UTS) 
	
	Чтобы получить текущую дату используется DateOnly now = DateTime.Now c модификатором ToString();
	Чтобы получить UNIX TIMESTAMP текущего времени long unixTimestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds() - получение в секундах;
	Чтобы вернуть UNIX TIMESTAMP в время/дата - DateTime dateTime = DateTimeOffset.FromUnixTimeSeconds(timestamp).DateTime, где timestamp - это секунды;
	Чтобы осуществлять форматирование даты и время используется метод ToString с шаблоном (d, D, t, T, f, F) или использовать кастомные шаблоны
			
14) В чем разница между значением const и readonly?
Ответ:
	Разница между const и readnoly
		const:															readnoly:	
			- Должен быть проинициализирован во время компиляции;				- Может быть проинициализирован при объявлении или в конструкторе;
			- Значение должно быть указано ДО компиляции;						- Подходит для значений, которые вычисляются во время выполнения.
			- Поддерживает только примитивные типы данных и enum.				- Можно использовать с любым типом данных, включая классы, структуры и массивы.
			
15) Интерфейсы IComparer и IComparable. Зачем нужны и как использовать?
Ответ:
	Данные интерфейсы используются для операций сортировки и сравнения объектов 
	IComparable - это интерфейс, который реализуется объектами, если эти объекты должны поддерживать сравнение с другими объектами того же типа. Определяет метод CompareTo, который используется для сравнения текущего объекта, с другим объектом того же типа. Принимает один параметр, с чем сравнить текущий объект.
	IComparer - это интерфейс для сравнения двух объектов произвольного типа. Определяет метод Compare, который принимает 2 объекта типа object и сравнивает их.

	IComparable - используется для сортировки по умолчанию.
	IComparer - используется если нужно применить кастомное правило сортировки или сравнения

16) Зачем нужно логирование?
Ответ: 
	Логирование - это процесс записи информации о работе программы, приложения и системы в специальные файлы для последующего анализа.
	Логирование нужно для: отладки и диагностике системы, мониторинга работы,  
	
17) Какие существуют базовые уровни логирования?
Ответ:
    - FATAL / CRITICAL (Критический)
        - Описание: Ошибки, приводящие к полной остановке системы.
        - Пример: Отказ критического сервиса, невозможность продолжить работу.
        - Действие: Требует немедленного вмешательства.

    - ERROR (Ошибка)
        - Описание: Серьёзные проблемы, но приложение может продолжать работать.
        - Пример: Сбой при обработке запроса, потеря соединения с БД.
        - Действие: Необходимо исправить в ближайшее время.

    - WARN (Предупреждение)
        - Описание: Потенциально опасные ситуации, которые пока не привели к ошибке.
        - Пример: Медленный запрос, нехватка места на диске.
        - Действие: Рекомендуется проверить, но срочность ниже, чем у ERROR.

    - INFO (Информация)
        - Описание: Основные события работы приложения.
        - Пример: Запуск/остановка сервиса, успешное выполнение операции.
        - Действие: Полезно для мониторинга нормальной работы.

    - DEBUG (Отладка)
        - Описание: Детальная техническая информация для разработчиков.
        - Пример: Параметры запроса, промежуточные результаты вычислений.
        - Действие: Используется при разработке и отладке, обычно отключён в production.

    - TRACE (Трассировка)
        - Описание: Максимально подробные данные, включая внутренние состояния системы.
        - Пример: Запросы к каждой строке БД, детализация сетевых пакетов.
        - Действие: Только для глубокой диагностики, сильно нагружает систему.
        
18) Какие инструменты для логирования используется в C#?      
Ответы:
	Встроенный API.NET Logging ( Microsoft.Extensions.Logging );
	Log4Net
	Nlog

19) Какие каналы записи логов существуют?
Ответы: 
	В логировании каналы записи (или sinks/targets/appenders) — это способы сохранения логов в различные хранилища или системы. Они определяют, куда именно будут отправляться логи: в файлы, базы данных, облачные сервисы и т. д.
	Основные места хранения: локальные файлы, консоль, БД, система сбора логов.
	Возможные: смс или мессенджеры, системные журналы, очередь сообщений, облачные сервисы и т.п.
	
20) Что такое stdout?
Ответ:
	stdout - это один из стандартных потоков ввывода, в который программа отправляет данные. По умолчанию он отправлен в консоль, но может быть перенаправлен на другое представление, 
	stdin - стандартный поток ввода
	stderr - поток вывода ошибок
	
21) Что такое LINQ? Методы Select(), Where(), Aggregate() в LINQ. Какие параметры передаются в эти методы? Какие еще полезные методы предоставляет LINQ?
Ответ:
	LINQ основан на 3 стандартных делегатах Predicate<T, bool>, Func<T,R>, Action<T>
	
	LINQ (Language Integrated Query) — это технология в .NET, которая позволяет писать запросы к данным напрямую в коде C# (или других языках .NET) с использованием удобного синтаксиса. LINQ работает с коллекциями, базами данных (LINQ to SQL, Entity Framework), XML (LINQ to XML) и другими источниками данных.
	В Select() - преобразует каждый элемент коллекции по заданому правилу
	В Where() - фильтрует элементы коллекции, оставляя только те, что удовлетворяют условию
	В Aggregate() - накопляет результат, применяя функцию к каждому элементу.
	Пример:
		var numbers = new List<int> {1, 2, 3, 4};
		var sum = numbers.Aggregate((acc, x) => acc + x); // 1+2+3+4 = 10;
		
	Другие функции LINQ:
		- OrderBy - сортировка по возврастанию;
		- OrderByDescending - сортировка по убыванию
		- GroupBy - группировка элементов по условиям;
		- Any -если хотя бы один элемент удовлетворяет условию;
		- All - все элементы удовлетворяют условию
		- Count - количество элементов;
		- Sum - сумма элементов;
		- Average - среднее значение элементов;
		- Take - кол-во элементов по которым нужно пройти; 
		- Skip - пропуск указанного кол-во элементов;
		- Dictinct - убрать дубликаты;

22) Что такое Deferred execution in LINQ?
Ответ: 
	Deferred execution - отложенное выполнение, то есть запрос выполняется не сразу а в момент когда нужен результат, например с методами (ToList, Count, First...).
	Пример:
		List<int> num = List<num>() {1,2,3,4,5,6,7,8,9}
		var query = num.Where(x => x >= 3);
		num.Remove(6);
		
		var newnum = query.ToList();
		foreach (var item in newnum)
		{
			Console.WriteLine(item);
		}

23) Преобразование типов через LINQ (LINQ to objects)
Ответ: 
	Существует 3 основных способа преобразования типов:
		- Явное преобразование с помощью метода Cast<T>, если в указанной коллекции найдется неподходящий элемент, то выскочит исключение InvalidCastException;
		- Безопасное преобразование с помощью OfType<T>, возвращает только те элементы, которые можно преобразовать к указанному типу;
		- Преобразование с помощью Select(), возвращает сразу преобразованные элементы, если не позаботиться об исключения, то будут выскакивать System.FormatException.
			Пример:
				var strings = new List<string> { "1", "2", "3", "4", "5" };
				var integers = strings.Select(s => int.Parse(s)).ToList();

24) Какие операции называют атомарными? Какие проблемы решают атомарные операции?
Ответ:
	Атомарные операции - это операции, которые выполняются как единное целое без прерывания. Они либо выполняются полностью, либо не выполняются.
	К атомарным операциям относятся:
		- Чтение и запись примитивных типов;
		- Операции с Interlocked 
	Проблемы которые решают атомарные операции:
		- предотвращение гонок данных;
		- Защита целостности данных.

25) Что такое многопоточность и зачем она нужна? Как создавать новые потоки? Что такое lock? Что такое Mutex?
Ответ:
	Многопоточность - это способность программы выполнять несколько операций одновремменно с использованием нескольких потоков исполнения в одном процессе. Каждый поток - это последовательность инструкций, которая может выполняться параллельно с другими потоками. Многопоточность нужна для ускорения работы приложения, для эффективного использования ресурсов  
	Асинхронность это подход в C# когда длительные операции выполняются без блокировки основного потока выполнение программы
	System.Threading - содержит основные инструменты для реализации многопоточности и работы с потоками.
	
	Есть 3 основных способа для создания потоков:
		- Класс Thread;
		Пример:
			Thread thread = new Thread(DoWork);
			thread.Start();
		- Класс ThreadPool:
		Пример:
			ThreadPool.QueueUserWorkItem(state => { Console.WriteLine("Работа в потоке из пула")});
		- Класс Task:
		Пример:
			Task.Run(() =>{Console.WriteLine("Работа в Task")});
	
	 lock - это ключевое слово в C# которое обеспечивает синхронизацию потоков предотвращая одновременный доступ нескольких потоков к критически важным секция кода. Работает на уровне программы
	 Пример:
	 	private readonly object _lockObject = new object();
		void ThreadSafeMethod()
		{
			lock (_lockObject)
			{
				// Критическая секция - только один поток может выполнять этот код одновременно
				Console.WriteLine("Безопасный доступ из потока " + Thread.CurrentThread.ManagedThreadId);
			}
		} 
	mutex - это примитив синхронизации, который предоставляет доступ только 1 потоку, если mutex удерживает поток, то остальные желающие будут приостановлены до тех пор, пока место не освободиться. Работает на уровне процессов, где процесс это экземпляр программы
	Dedlock - взаимная блокировка 

26) Чем различаются Task и Thread?
Ответ:
	Task - это задача. 
	Работает на ThreadPool
	Используется асинхронности. 
	Может вернуть результат. 
	Задача, которая возвращает результат
	
	Thread - это поток.
	Работает самостоятельно с потоками 
	Используется в многопоточности. 
	Не возвращает результат. 
	Просто набор инструкций

27) Async / await: как работает? Как использовать?
Ответ: 
	async/await это ключевые слова для асинхронного программирования, позволяющие писать неблокирующийся код, который легко поддерживается и читается
	async помечает метод как асинхронный. Такой метод должен возвращать:
		- Task, если нет возвращаемого объекта;
		- Task<T>, если возвращает <T>;
		- Void, только для событий и event handlers. Такой способ не рекомендуется, т.к. он может уронить приложение.
	
	await приостанавливает выполнения метода до завершение задачи, но не блокирует поток.
		- Если задача завершена - метод продолжает работу синхроно
		- Если задача не завершена - управление возвращается вызывающему коду, а поток освобождается 
	Под капотом получается async метод преобразуется в машину состояний IAsyncStateMachine:
		- Запоминае прогресс выполненого метода;
		- Приостанавливает работу при await;
		- Возобновляет выполнение после завершенной задачи 
	
28) Что такое состояние гонок?  Как можно его избегать? В каких случаях может возникать состояние гонок?
Ответ:
	Состояние гонок - это ошибка в многопоточном или в параллельном программировании, когда результат выполнения программы зависит от порядка выполнения потоков или процессов. Это происходит когда несколько потоков одновременно обращаются к общим данным и хотя бы один из них изменяет их.
	Состояние гонки возникает, когда поведение программы зависит от относительного порядка выполнения операций в разных потоках.
	Чтобы избегать данной ошибки: 
		- блокировки (lock, Monitor)
		- атомарные операции (Interlocked)
		- неизменяемые (immutable) объекты
		- потокобезопасные коллекции (ConcurrentBag, ConcurrentQueue)
		- синхронизация с помощью Semaphore, Mutex
		- использование async/await для асинхронных операций
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
Task:
	если указать в классе async, но в блоке не указать await, то будет выполняться синхронно, а не асинхронно
	
ThreadPool - это контейнер который содержит уже созданные потоки, которые ожидают задачу для выполнения:
	это механизм который в C# который позволяет эффективно управлять потоками, избегая постоянного удаленния\добавления, что позволяет более экономно управлять ресурсами.
